# ðŸƒ prisma-test-utils

[![CircleCI](https://circleci.com/gh/prisma/prisma-test-utils/tree/master.svg?style=shield)](https://circleci.com/gh/prisma/prisma-test-utils/tree/master)
[![codecov](https://codecov.io/gh/prisma/prisma-test-utils/branch/master/graph/badge.svg)](https://codecov.io/gh/prisma/prisma-test-utils)
[![npm version](https://badge.fury.io/js/prisma-test-utils.svg)](https://badge.fury.io/js/prisma-test-utils)

> âš ï¸ **This project is currently unmaintained. Please reach out in the [`#prisma2-preview`](https://prisma.slack.com/messages/CKQTGR6T0/) channel on the [Prisma Slack](https://slack.prisma.io) if you're interested in collaborating on it.**

In testing workflows, generating seed data usually includes a lot of boilerplate. We rely on hardcoded fixtures that need to be migrated with changing code.

`prisma-test-utils` solve that by generating test util functions based on your Prisma schema. As your application evolves, the generated data also evolves deterministically.

## Features

- ðŸ™ˆ **Data model agnostic:** Optimised for you datamodel.
- ðŸ¦‘ **Flexible:** Cherry picked default settings.
- ðŸ¶ **Out-of-the-box usage:** Plug-in generator for your Prisma schema.
- ðŸ  **Seeds mock data:** Populates your database with mock data.
- ðŸ¦‹ **Per-test database:** Creates an isolated database for each test.

## Installation

No installation! Comes preinstalled with `prisma2`! ðŸŽ‰

## Configuration

```prisma
generator test-utils {
  provider = "prisma-test-utils"
  output = "node*modules/@generated/test-utils"
}
```

## Usage

`prisma-test-utils` pack two incredibly useful functions. The first one, `pool`, can be used to create a pool of databases that you can use during testing, and are wiped after you've finished. The second one, `seed`, helps you populate your data with vast amount of data.

### Database Pools

We can configure our pool requirements before running any test cases.

```js
import SQLitePool, { Pool } from '@generated/prisma-test-utils'

let pool: Pool

beforeAll(async () => {
  pool = new SQLitePool({
    pool: {
      min: 3,
      max: 5,
    },
  })
})
```

This allows us to request an isolated database per test case

```ts
test('one of my parallel tests', async () => {
  /* Acquire new db instance. */
  const db = await pool.getDBInstance()

  // Write the test case logic
  const client = new Photon({
    datasources: {
      db: db.url,
    },
  })

  /* Release the instance. */
  client.disconnect()
  pool.releaseDBInstance(db)
})
```

**API**

```ts
/* All pool instances. */

class Pool {
  async getDBInstance(): Promise<DBInstance>
  async releaseDBInstance(db: DBInstance): Promise<void>
  async run<T>(fn: (db: DBInstance) => Promise<T>): Promise<T>
  async drain(): Promise<void>
}

/* PostgreSQL */

interface PostgreSQLConnection {
  host: string
  port: number
  user: string
  password?: string
  database: string
  schema: string
}

interface PostgreSQLPoolOptions {
  connection: (id: string) => PostgreSQLConnection
  pool?: {
    max?: number
  }
}

/* MySQL */

interface MySQLConnection {
  host: string
  port: string
  user: string
  password?: string
  database: string
}

interface MySQLPoolOptions {
  connection: (id string) => MySQLConnection
  pool?: {
    max?: number
  }
}

/* SQLite */

interface SQLitePoolOptions {
  databasePath: (id: string) => string
  pool?: {
    max?: number
  }
}
```

### Seeding

```ts
import Photon from '@generated/photon'
import seed from '@generated/test-utils/seed'

test('test with seed data', async () => {
  await seed({
    client,
    models: kit => ({
      _: {
        /* Default number of instances. */
        amount: 500,
      },
      Blog: {
        factory: {
          /* Use functions from the kit. */
          name: kit.faker.sentence,
          /* Define custom mocks. */
          description: 'My custom blog description',
          /* Define custom mock functions. */
          entry: () => {
            return `A generated entry from the function.`
          },
          /* Manage relations. */
          posts: {
            max: 100,
          },
        },
      },
    }),
  })

  const blogs = await client.blogs()
})
```

**Options**

It is possible to selectively override the seed generation making the seeding workflow very flexible.

> All options are autogenerated and checked at compile time. You'll be warned about any relation constraints that your datamodel presents.

```ts
beforeAll(async () => {
  const data = await seed(
    photon,
    bag => ({
      Post: {
        amount: 5,
        factory: {
          published: 'false',
        },
      },
    }),
    {
      seed: 42,
      silent: false,
      instances: 5,
    },
  )
})
```

## LICENSE

MIT @ Prisma
